import Foundation
@preconcurrency import Combine
@preconcurrency import WalletConnectSign
import ReownWalletKit

public final class WalletConnectSessionPublisher: Sendable {
  internal let pushOnSignSubject = PassthroughSubject<PushOnSign, Never>()
  
  /// Your Wallet should allow users to scan a QR code generated by dapps. You are responsible for implementing it on your own. For testing, you can use our test dapp at: https://react-app.walletconnect.com/, which is v2 protocol compliant. Once you derive a URI from the QR code call pair method: try await WallectConnectServiceImpl.instance.pair(uri: uri)
  /// if everything goes well, you should handle following event:
  public var sessionProposal: AnyPublisher<(proposal: Session.Proposal, context: VerifyContext?), Never> {
    return Sign.instance.sessionProposalPublisher
  }
  
  /// After the session is established, a dapp will request your wallet's users to sign a transaction or a message. Requests will be delivered by the following publisher:
  public var sessionRequest: AnyPublisher<(request: Request, context: VerifyContext?), Never> {
    return Sign.instance.sessionRequestPublisher
  }
  
  public var socketConnectionStatus: AnyPublisher<SocketConnectionStatus, Never> {
    return Sign.instance.socketConnectionStatusPublisher
  }
  
  /// When session is sucessfully approved sessionSettlePublisher will publish a Session
  public var sessionSettle: AnyPublisher<Session, Never> {
    return Sign.instance.sessionSettlePublisher
  }
  
  public var sessionDelete: AnyPublisher<(String, Reason), Never> {
    return Sign.instance.sessionDeletePublisher
  }
  
  public var sessionResponse: AnyPublisher<Response, Never> {
    return Sign.instance.sessionResponsePublisher
  }
  
  public var sessionRejection: AnyPublisher<(Session.Proposal, Reason), Never> {
    return Sign.instance.sessionRejectionPublisher
  }
  
  public var sessionUpdate: AnyPublisher<(sessionTopic: String, namespaces: [String : SessionNamespace]), Never> {
    return Sign.instance.sessionUpdatePublisher
  }
  
  public var authRequests: AnyPublisher<(request: WCAuthRequest, context: VerifyContext?), Never> {
    return WalletKit.instance.authenticateRequestPublisher
  }
  
  /// Publisher that sends session event
  ///
  /// Event will be emited on dApp client only
  public var sessionEvent: AnyPublisher<(event: Session.Event, sessionTopic: String, chainId: Blockchain?), Never> {
    return Sign.instance.sessionEventPublisher
  }
  
  /// Publisher that sends session topic when session is extended
  ///
  /// Event will be emited on controller and non-controller clients.
  public var sessionExtend: AnyPublisher<(sessionTopic: String, date: Date), Never> {
    return Sign.instance.sessionExtendPublisher
  }
  
  /// Publisher that sends session topic when session ping received
  ///
  /// Event will be emited on controller and non-controller clients.
  public var ping: AnyPublisher<String, Never> {
    return Sign.instance.pingResponsePublisher
  }
  
  public var pushOnSign: AnyPublisher<PushOnSign, Never> {
    return pushOnSignSubject.eraseToAnyPublisher()
  }
}
